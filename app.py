# from streamlit.web import cli
import streamlit as st
import pandas as pd
# from langchain.llms import HuggingFacePipeline

from langchain_huggingface import HuggingFaceEndpoint

# from langchain.agents import create_react_agent
from dotenv import load_dotenv
import os
# from langchain_experimental.agents.agent_toolkits import create_pandas_dataframe_agent

# from langchain.agents import AgentType, Tool, initialize_agent

# from langchain_community.agent_toolkits.load_tools import load_tools

# from datetime import datetime, timedelta
import fin_tools

# from langchain.prompts import PromptTemplate
# from langchain.chains import LLMChain, SimpleSequentialChain, SequentialChain
# from langchain_experimental.agents.agent_toolkits import create_python_agent
# from langchain_experimental.tools import PythonREPLTool
from langchain_experimental.utilities import PythonREPL

# from langchain.agents.agent_types import AgentType

from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.chains.combine_documents import create_stuff_documents_chain
from langchain_core.prompts import ChatPromptTemplate
from langchain.chains import create_retrieval_chain
from langchain_community.vectorstores import FAISS

from langchain_huggingface.embeddings import HuggingFaceEmbeddings
# from langchain.chains import ConversationalRetrievalChain
# from langchain.chains import ConversationChain
# from langchain.chains.conversation.memory import ConversationBufferWindowMemory
from langchain.prompts import (
    # SystemMessagePromptTemplate,
    # HumanMessagePromptTemplate,
    ChatPromptTemplate,
    MessagesPlaceholder
)

from streamlit_chat import message
from langchain_community.document_loaders import PyPDFDirectoryLoader
from langchain.chains import create_history_aware_retriever
from langchain_core.chat_history import BaseChatMessageHistory
from langchain_community.chat_message_histories import ChatMessageHistory
from langchain_core.runnables.history import RunnableWithMessageHistory





load_dotenv()
os.environ["HUGGINGFACEHUB_API_TOKkEN"] = st.secrets["HUGGINGFACEHUB_API_TOKkEN"] 
          
st.header("Your Financial Assistance")
st.subheader("General information about the dataset")

embedder = HuggingFaceEmbeddings()

with st.sidebar:
    st.write("**Explanation of the most important financial features:**")
    st.caption(''' **Operating Cash Flow**
               Definition: The cash generated from the normal operations of a business, indicating the company's ability to generate sufficient cash flow to maintain or expand operations.
It represents the cash inflows and outflows from the core business activities, excluding capital expenditures and financing.

**Capital Expenditure (CapEx)**
Funds used by a company to acquire, upgrade, and maintain physical assets such as property, buildings, or equipment.
These expenditures are used to invest in the company's infrastructure and are usually long-term investments.

**Free Cash Flow (FCF)**
The cash generated by a company after accounting for capital expenditures.
It measures the cash available to the company for expansion, dividends, debt repayment, or other purposes.

**Investing Cash Flow**
The section of a company's cash flow statement that reports the cash spent on and generated from investment activities.
It includes cash flows from the purchase and sale of assets, investments, and capital expenditures.

**Cash Flow From Continuing Financing Activities**
The cash flow resulting from activities that involve the financing of the company, such as borrowing and repaying debt, issuing stock, and paying dividends.
It indicates how a company finances its operations and growth through debt, equity, and dividend payments.

**Net Long Term Debt Issuance**
The net amount of long-term debt issued minus the amount repaid.
It shows whether the company is borrowing more long-term debt than it is repaying.

**Total Assets**
The total resources owned by a company that are expected to provide future economic benefits.
Includes both current assets (cash, inventory, receivables) and non-current assets (property, equipment, long-term investments).

**Total Liabilities Net Minority Interest**
The sum of all the financial obligations of a company, excluding the interests of minority shareholders in the company's subsidiaries.
It represents the company's debts and financial obligations.

**Stockholders' Equity**
The residual interest in the assets of a company after deducting liabilities, representing the ownership interest of the shareholders.
Also known as shareholders' equity, it includes common stock, retained earnings, and additional paid-in capital.

**Current Liabilities**
The company's short-term financial obligations that are due within one year.
Includes accounts payable, short-term debt, and other short-term liabilities.

**Working Capital**
The difference between a company's current assets and current liabilities.
It measures the company's short-term liquidity and operational efficiency.

**Long Term Debt**
The debt that is due for repayment in more than one year.
Includes loans, bonds, and other forms of long-term borrowing.

**Total Revenue**
The total amount of income generated by the sale of goods or services before any expenses are deducted.
Represents the company's gross income from its business operations.

**Earnings Before Interest and Taxes (EBIT)**
The company's profit before interest expenses and income taxes are deducted.
It measures the company's profitability from operations.

**Net Income**
The total profit of a company after all expenses, including taxes and interest, have been deducted from total revenue.
Often referred to as the "bottom line," it represents the company's overall profitability.

**Gross Profit**
The profit a company makes after deducting the costs associated with making and selling its products, or the costs associated with providing its services.
It indicates how efficiently a company is producing and selling its goods or services.

**Basic Earnings Per Share (EPS)**
The portion of a company's profit allocated to each outstanding share of common stock.
It measures the profitability of a company on a per-share basis.

**Earnings From Equity Interest Net of Tax**
The earnings that a company receives from its investments in other companies, net of taxes.''')

repo_id = "mistralai/Mistral-7B-Instruct-v0.2" # "meta-llama/Meta-Llama-3-8B" #"core42/jais-13b-chat" #
llm = HuggingFaceEndpoint(
    repo_id=repo_id,
    max_length=500,
    temperature=0.5,
    huggingfacehub_api_token=os.environ["HUGGINGFACEHUB_API_TOKEN"],
)

st.divider()
tab1, tab2, tab3, tab4 = st.tabs(["Financial Assistant", "ChatBot", "General overview", "Predictors"])

def preparing_db():
    pdf_folder_path = "EDGAR_annual_reports/"
    loader = PyPDFDirectoryLoader(pdf_folder_path)
    documents = loader.load()
    text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=50)
    chunck_docs = text_splitter.split_documents(documents)

    db = FAISS.from_documents(chunck_docs, embedder)
    db.save_local('faiss_index')
    return db


with tab1: 
    st.header('Ask about insights and recommendations')
    st.write("Welcome to the AI Assistant ChatBox!")

    try:
       with st.spinner("Preparing database ..."):
            db = FAISS.load_local('faiss_index', embedder, allow_dangerous_deserialization=True)
            retriever = db.as_retriever()
    except:
        db = preparing_db()

    if 'responses' not in st.session_state:
        st.session_state['responses'] = ["How can I assist you?"]

    if 'requests' not in st.session_state:
        st.session_state['requests'] = []

    contextualize_q_system_prompt = (
        "Given a chat history and the latest user question "
        "which might reference context in the chat history, "
        "formulate a standalone question which can be understood "
        "without the chat history. Do NOT answer the question, just "
        "reformulate it if needed and otherwise return it as is."
    )
    contextualize_q_prompt = ChatPromptTemplate.from_messages(
        [
            ("system", contextualize_q_system_prompt),
            MessagesPlaceholder("chat_history"),
            ("human", "{input}"),
        ]
    )
    history_aware_retriever = create_history_aware_retriever(
        llm, retriever, contextualize_q_prompt
    )
    ### Answer question ###
    qa_system_prompt = """You are an assistant for question-answering tasks. \
    Use the following pieces of retrieved context to answer the question. \
    If you don't know the answer, just say that you don't know. \
    Use three sentences maximum and keep the answer concise.\

    {context}"""
    qa_prompt = ChatPromptTemplate.from_messages(
        [
            ("system", qa_system_prompt),
            MessagesPlaceholder("chat_history"),
            ("human", "{input}"),
        ]
    )
    question_answer_chain = create_stuff_documents_chain(llm, qa_prompt)

    rag_chain = create_retrieval_chain(history_aware_retriever, question_answer_chain)

    ### Statefully manage chat history ###
    store = {}


    def get_session_history(session_id: str) -> BaseChatMessageHistory:
        if session_id not in store:
            store[session_id] = ChatMessageHistory()
        return store[session_id]


    conversational_rag_chain = RunnableWithMessageHistory(
        rag_chain,
        get_session_history,
        input_messages_key="input",
        history_messages_key="chat_history",
        output_messages_key="answer",
    )

    response_container = st.container()
    textcontainer = st.container()

    with textcontainer:
        query = st.text_input("Add a question? ", key="input") #, on_change=submit)
        if query:
            with st.spinner("thinking..."):
                res = conversational_rag_chain.invoke({"input": query},
                                                    config={"configurable": {"session_id": "abc123"}})
                response = res['answer']
                resource = res['context'][0]
                st.write(f'the resource is : {resource}')
                st.session_state.requests.append(query)
                st.session_state.responses.append(response)
        # st.session_state.input = ""
        

    with response_container:
        if st.session_state['responses']:
            for i in range(len(st.session_state['responses'])):
                message(st.session_state['responses'][i],key=str(i))
                if i < len(st.session_state['requests']):
                    message(st.session_state["requests"][i], is_user=True,key=str(i)+ '_user')

with tab2:
    st.header('Chat with the LLM')
    
    if 'responses2' not in st.session_state:
        st.session_state['responses2'] = ["How can I assist you?"]

    if 'requests2' not in st.session_state:
        st.session_state['requests2'] = []

    ### Statefully manage chat history ###

    response_container2 = st.container()
    textcontainer2 = st.container()

    with textcontainer2:
        query2 = st.text_input("Add a question")
        if query2 is not None and query2 != '':
            with st.spinner("thinking..."):
                response = llm(query2)
                
                st.session_state.requests2.append(query2)
                st.session_state.responses2.append(response)
                
    
    with response_container2:
        if st.session_state['responses2']:
            for i in range(100, 100 + len(st.session_state['responses2'])):
                message(st.session_state['responses2'][i-100],key=str(i))
                if i-100 < len(st.session_state['requests2']):
                    message(st.session_state["requests2"][i-100], is_user=True,key=str(i)+ '_user')

with tab3:
    st.header('Recent Financial Data')
    data = pd.read_csv('companies_full_financial_data.csv')
    # st.write(llm.invoke('stock price in 2025 of Meta ')) #, kwargs={'max_lenght': 3})

    comp_name = pd.read_csv('companies_stock_names.csv')
    company_name = st.selectbox('Select a company', comp_name['name'])

    if company_name:
        symbol = comp_name.loc[comp_name['name'] == company_name, 'symbol'].values[0]

        with st.spinner('Plotting basic financial features ...'):
            fin_tools.basic_info(symbol)
        
        st.subheader('Candlestick chart')
        st.write('')
        with st.spinner('Plotting Candlestick Chart ...'):
            fin_tools.creat_candle_chart(symbol)

with tab4:
    st.header('Prediction of future prices')
    st.subheader('**Arima model forcasting:**')
    with st.spinner('In progress ...'):
        fin_tools.arima_forcasting_close(symbol)

    st.subheader('**LSTM model Prediction:**')
    
    
    df = fin_tools.get_recent_data(symbol)
    with st.spinner('Training special prediction model for this data may take up to 5 min..'):
        model, scaler, rmse, _ = fin_tools.build_train_lstm_model(df)

    st.write('**How many days do you want to predict the price for?**')
    days = st.text_input('Number of Days')
    if days:
        d = int(days)
    else:
        d = 10

    with st.spinner('Predictind Futher stock price ..'):
            fin_tools.predict_future_prices(model, df, scaler, days=d)
    
# Making tool list

# tools=[
#     # Tool(
#     #     name="get stock price prediction",
#     #     func=fin_tools.predict_stock_prices,
#     #     description="Use when you are asked to predict the price of stock. This will output predicted stock price. You should input the company name to it "
#     # ),
#     Tool(
#         name="get stock data",
#         func=fin_tools.get_recent_data,
#         description="Use when you are asked to evaluate or analyze a stock. This will output historic share price data. You should input the stock ticker to it "
#     ),
#     Tool(
#         name="DuckDuckGo Search",
#         func=fin_tools.DuckDuck_search.run,
#         description="Use only when you need to get NSE/BSE stock ticker from internet, you can also get recent stock related news. Dont use it for any other analysis or task"
#     ),
#     Tool(
#         name="get recent news",
#         func=fin_tools.get_recent_stock_news,
#         description="Use this to fetch recent news about stocks"
#     ),

#     # Tool(
#     #     name="get financial statements",
#     #     func=fin_tools.get_financial_statements,
#     #     description="Use this to get financial statement of the company. With the help of this data companys historic performance can be evaluaated. You should input stock ticker to it"
#     # )


# ]

# python_repl = PythonREPL()

# @st.cache_resource
# def python_agent():
#     agent_executor = create_python_agent(
#         llm=llm,
#         tool=[python_repl],
#         verbose=True,
#         agent_type=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
#         handle_parsing_errors=True,
#         iter = 5,
#         )
#     return agent_executor

# @st.cache_data
# def python_solution(my_data_problem, selected_algorithm, user_csv):
#     solution = python_agent().run(
#         f"Write a Python script to solve this: {my_data_problem}, using this algorithm: {selected_algorithm}, using this as your dataset: {user_csv}."
#     )
#     return solution




# df = fin_tools.predict_future_prices(model, data, scaler, days=100)
# st.write(python_solution('predict the stock price in 2030 using LSTM', 'LSTM', df))


# zero_shot_agent=initialize_agent(
#     llm=llm,
#     agent="zero-shot-react-description",
#     tools=tools,
#     verbose=True,
#     max_iteration=4,
#     return_intermediate_steps=True,
#     handle_parsing_errors=True
# )

# response = zero_shot_agent({"input":"Shall I invest in GOOG?"})
# query = st.chat_input('input something!')

# response =llm(st
# r(query))

# st.write(response)


# st.is_clicked = st.button('click ok')
# if __name__ == "__main__":
#     cli.main_run(["app.py"])
    # cli.main_run(["app.py", "--server.port", "1000"])
